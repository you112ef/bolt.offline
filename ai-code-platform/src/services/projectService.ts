interface Project {\n  id: string;\n  name: string;\n  description: string;\n  code: string;\n  createdAt: string;\n  updatedAt?: string;\n  tags?: string[];\n}\n\nconst PROJECTS_KEY = 'ai-code-platform-projects';\nconst MAX_PROJECTS = 50; // Limit to prevent localStorage overflow\n\n// Save a project to localStorage\nexport async function saveProject(project: Project): Promise<void> {\n  try {\n    const existingProjects = await getProjects();\n    \n    // Check if project already exists (update case)\n    const existingIndex = existingProjects.findIndex(p => p.id === project.id);\n    \n    if (existingIndex >= 0) {\n      // Update existing project\n      existingProjects[existingIndex] = {\n        ...project,\n        updatedAt: new Date().toISOString()\n      };\n    } else {\n      // Add new project\n      existingProjects.unshift({\n        ...project,\n        createdAt: project.createdAt || new Date().toISOString()\n      });\n      \n      // Keep only the most recent projects\n      if (existingProjects.length > MAX_PROJECTS) {\n        existingProjects.splice(MAX_PROJECTS);\n      }\n    }\n    \n    localStorage.setItem(PROJECTS_KEY, JSON.stringify(existingProjects));\n  } catch (error) {\n    console.error('Failed to save project:', error);\n    throw new Error('Failed to save project to local storage');\n  }\n}\n\n// Get all projects from localStorage\nexport async function getProjects(): Promise<Project[]> {\n  try {\n    const stored = localStorage.getItem(PROJECTS_KEY);\n    if (!stored) {\n      return [];\n    }\n    \n    const projects = JSON.parse(stored) as Project[];\n    \n    // Sort by creation date (newest first)\n    return projects.sort((a, b) => \n      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n    );\n  } catch (error) {\n    console.error('Failed to load projects:', error);\n    return [];\n  }\n}\n\n// Get a specific project by ID\nexport async function getProject(id: string): Promise<Project | null> {\n  try {\n    const projects = await getProjects();\n    return projects.find(p => p.id === id) || null;\n  } catch (error) {\n    console.error('Failed to get project:', error);\n    return null;\n  }\n}\n\n// Delete a project by ID\nexport async function deleteProject(id: string): Promise<void> {\n  try {\n    const projects = await getProjects();\n    const filtered = projects.filter(p => p.id !== id);\n    localStorage.setItem(PROJECTS_KEY, JSON.stringify(filtered));\n  } catch (error) {\n    console.error('Failed to delete project:', error);\n    throw new Error('Failed to delete project');\n  }\n}\n\n// Export project as ZIP\nexport async function exportProjectAsZip(project: Project): Promise<void> {\n  try {\n    const JSZip = (await import('jszip')).default;\n    const { saveAs } = await import('file-saver');\n    \n    const zip = new JSZip();\n    \n    // Create a basic project structure\n    zip.file('README.md', `# ${project.name}\\n\\n${project.description}\\n\\nGenerated with AI Code Platform`);\n    \n    // Package.json\n    const packageJson = {\n      name: project.name.toLowerCase().replace(/\\s+/g, '-'),\n      version: '1.0.0',\n      description: project.description,\n      main: 'src/App.tsx',\n      scripts: {\n        dev: 'vite',\n        build: 'vite build',\n        preview: 'vite preview'\n      },\n      dependencies: {\n        react: '^18.2.0',\n        'react-dom': '^18.2.0'\n      },\n      devDependencies: {\n        '@types/react': '^18.2.0',\n        '@types/react-dom': '^18.2.0',\n        '@vitejs/plugin-react': '^4.0.0',\n        typescript: '^5.0.0',\n        vite: '^4.0.0',\n        tailwindcss: '^3.3.0',\n        autoprefixer: '^10.4.0',\n        postcss: '^8.4.0'\n      }\n    };\n    \n    zip.file('package.json', JSON.stringify(packageJson, null, 2));\n    \n    // Vite config\n    const viteConfig = `import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n})`;\n    \n    zip.file('vite.config.ts', viteConfig);\n    \n    // Tailwind config\n    const tailwindConfig = `/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\n    \"./index.html\",\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}`;\n    \n    zip.file('tailwind.config.js', tailwindConfig);\n    \n    // PostCSS config\n    const postcssConfig = `export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}`;\n    \n    zip.file('postcss.config.js', postcssConfig);\n    \n    // HTML file\n    const htmlFile = `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>${project.name}</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>`;\n    \n    zip.file('index.html', htmlFile);\n    \n    // CSS file\n    const cssFile = `@tailwind base;\n@tailwind components;\n@tailwind utilities;`;\n    \n    zip.file('src/index.css', cssFile);\n    \n    // Main file\n    const mainFile = `import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.tsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)`;\n    \n    zip.file('src/main.tsx', mainFile);\n    \n    // App component\n    zip.file('src/App.tsx', project.code);\n    \n    // TypeScript config\n    const tsConfig = {\n      compilerOptions: {\n        target: 'ES2020',\n        useDefineForClassFields: true,\n        lib: ['ES2020', 'DOM', 'DOM.Iterable'],\n        module: 'ESNext',\n        skipLibCheck: true,\n        moduleResolution: 'bundler',\n        allowImportingTsExtensions: true,\n        resolveJsonModule: true,\n        isolatedModules: true,\n        noEmit: true,\n        jsx: 'react-jsx',\n        strict: true,\n        noUnusedLocals: true,\n        noUnusedParameters: true,\n        noFallthroughCasesInSwitch: true\n      },\n      include: ['src'],\n      references: [{ path: './tsconfig.node.json' }]\n    };\n    \n    zip.file('tsconfig.json', JSON.stringify(tsConfig, null, 2));\n    \n    // Generate and download ZIP\n    const content = await zip.generateAsync({ type: 'blob' });\n    const filename = `${project.name.toLowerCase().replace(/\\s+/g, '-')}.zip`;\n    saveAs(content, filename);\n  } catch (error) {\n    console.error('Failed to export project:', error);\n    throw new Error('Failed to export project as ZIP');\n  }\n}\n\n// Get project statistics\nexport async function getProjectStats(): Promise<{\n  totalProjects: number;\n  recentProjects: number;\n  storageUsed: number;\n}> {\n  try {\n    const projects = await getProjects();\n    const now = new Date();\n    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    \n    const recentProjects = projects.filter(p => \n      new Date(p.createdAt) > weekAgo\n    ).length;\n    \n    const storageUsed = new Blob([localStorage.getItem(PROJECTS_KEY) || '']).size;\n    \n    return {\n      totalProjects: projects.length,\n      recentProjects,\n      storageUsed\n    };\n  } catch (error) {\n    console.error('Failed to get project stats:', error);\n    return {\n      totalProjects: 0,\n      recentProjects: 0,\n      storageUsed: 0\n    };\n  }\n}\n\n// Clear all projects (with confirmation)\nexport async function clearAllProjects(): Promise<void> {\n  try {\n    localStorage.removeItem(PROJECTS_KEY);\n  } catch (error) {\n    console.error('Failed to clear projects:', error);\n    throw new Error('Failed to clear all projects');\n  }\n}